# Instructivo para crear un nuevo proyecto de Procedimiento de Control Estad√≠stico Multivariable
# PCA + T2 + Q/SPE + Proyecci√≥n + Descomposici√≥n  

# Aqu√≠ inicia todo cuando no tenemos nada y el cliente nos entrega los primeros datos
# Comienza la Calibraci√≥n Multivariable PCA


# --- Carga de librer√≠as necesarias --- #

library(readxl)                                     # Cargamos poque casi todo viene en Excel
library(GGally)
library(plotly)

# --- Preparaci√≥n de datos recibidos --- #
 
file.path <- file.choose()                          # Obtenemos ruta del archivo Exce,l
italian.wine.data.raw <- read_xlsx(file.path)       # Cargamos datos del archivo Excel
#View(italian.wine.data.raw)                         # Echamos un vistazo al archivo Excel  


# --- Transformaci√≥n del archivo Excel a foramto rda --- #

saveRDS(
  italian.wine.data.raw,                            # Nombre del objetvo que guardaremos
  file = "italian_wine_data_raw.rds",               # Nombre del archivo rda que guardaremos
  compress = "xz"                                   # Tipo de compresi√≥n
)

# Nunca vuelves a tocar el archivo Excel


# --- Obtenemos archivos RDS y empezamos a trabajar y analizar y procesas ---#
italian.wine.data.raw <- readRDS(
                                 file.path(
                                           getwd(),
                                            "italian_wine_data_raw.rds"
                                          )
                                )


# --- Comenzamos el procesamiento y an√°lisis de los datos --- #

X.Grignolino <- as.matrix(italian.wine.data.raw[60:130, -1])                    # Extraemos la secci√≥n que nos interesa analizar

#X.Grignolino <- X.Grignolino[-c(11, 38, 44, 63),]

pca.Grignolino <- prcomp(x = X.Grignolino,                                      # Corremos modelo PCA para secci√≥n de inter√©s
                     center = TRUE, 
                     scale. = TRUE)


# --- Visualizaci√≥n de scree plot --- #

dev.new()
plot(pca.Grignolino$sdev^2,                                  # Buscamos el corte en la curva suave del codo
     type = "b",                                         # Ese es el n√∫mero de PCs que aplicaremos   
     ylab = "Varianza")


# --- Extracci√≥n de elementos del modelo PCA --- #

pca.sigma    <- pca.Grignolino$sdev                          # Eigenvalues

pca.loadings <- pca.Grignolino$rotation                      # Eigenvectors P

pca.center   <- pca.Grignolino$center                        # Promedios individuales

pca.scale    <- pca.Grignolino$scale                         # Desviaciones est√°ndar individuales

pca.scores   <- pca.Grignolino$x                             # Scores T

pca.summary  <- summary(pca.Grignolino)                      # Resumen 


# --- Obtenci√≥n de Matriz de Covarianza de Componentes de Intere√©s --- ###

scores <- pca.scores[, c(1,2,3,4,5,6,7,8,9)]             # Extraemos los scores de los componentes de inter√©s

Lambda_scores <- cov(scores)                             # Obtenemos matriz de covarianza de los componentes de inter√©s


# --- Funci√≥n para organizar los loadings y variables de cada PC por separado --- #

pca_loadings_variables_tabla <- function(pca, k, digits = 3) { 
  
  load <- pca$rotation[, k]
  
  pos <- load[load > 0]
  neg <- load[load < 0]
  
  pos <- sort(pos, decreasing = TRUE)
  neg <- sort(neg, decreasing = TRUE)
  
  data.frame(
    variable = c(names(pos), names(neg)),
    loading  = round(c(pos, neg), digits),
    row.names = NULL
  )
}


# --- Creaci√≥n de tablas de loadings por variables, los llamamos Subsistemas --- #

subsistema1_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 1)
subsistema2_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 2)
subsistema3_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 3)
subsistema4_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 4)
subsistema5_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 5)
subsistema6_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 6)
subsistema7_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 7)
subsistema8_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 8)
subsistema9_loadings <- pca_loadings_variables_tabla(pca = pca.Grignolino, k = 9)


# --- Quimiometr√≠a T2 Hotelling seg√∫n Algoritmo de Jackson --- #

pca.lambda <- diag(Lambda_scores)                           # Œª‚ÇÅ ‚Ä¶ Œª‚ÇÑ seleccionados seg√∫n el scree plot  
pca.scores.select <- pca.scores[, 1:9]                      # scores T (n √ó 4)


T2 <- rowSums(                                              # C√°lculo de T2 Hotelling para el vector del conjunto de calibraci√≥n 
  sweep(x = pca.scores.select^2, 
        MARGIN = 2, 
        STATS = pca.lambda, 
        FUN = "/")
)

# --- Quimiometr√≠a para calcular UCL de T2 Hotelling --- #

p <- 9                                                     # N√∫mero de PCs previamente seleccionados 
n <- 30                                                    # N√∫mero de observaciones del conjunto de calibraci√≥n
f <- qf(p = 0.95, df1 = p, df2 = n - p)                    # Estad√≠stico F de Fisher

T2.limit <- p * (n - 1) / (n - p) * f                      # C√°lculo de UCL seg√∫n Jackson


# --- Quimiometr√≠a para conocer cada distancia ortogonal Q (SPE) de cada observaci√≥n en todo el conjunto de calibraci√≥n --- #

A <- 9                                                     # Definici√≥n del n√∫mero de PCs 

Xhat <- pca.scores[, 1:A] %*% t(pca.loadings[, 1:A])       # Primero obtenemos la matriz de valores estimados

E <- scale(X.Grignolino,                                       # Restamos valores estimados de valores originales
           center = pca.center, 
           scale = pca.scale) - Xhat

Q <- rowSums(E^2)                                          # Obtenemos el vector del estad√≠stico Q (SPE)

length(Q) == nrow(X.Grignolino)      # TRUE                    # Verificamos que no falte nada
Q >= 0                           # siempre                 # Esta condici√≥n siempre se debe cumplir


# --- Algoritmo de Jackson y Mudholkar para conocer Q_alpha --- #


lambda <- pca.Grignolino$sdev^2                                # Obtenemos todas las varianzas Œª de todo el modelo 
lambda_res <- lambda[(A + 1):length(lambda)]               # Seleccionamos solo las varianzas Œª que quedan fuera del modelo


theta1 <- sum(lambda_res)                                  # Procesamos las varianzas Œª theta 1, theta 2 y theta 3
theta2 <- sum(lambda_res^2)
theta3 <- sum(lambda_res^3)


stopifnot(theta1 > 0, theta2 > 0, theta3 > 0)              # Ninguna theta debe ser negativa


h0 <- max(                                                 # Obtenemos el valor h0, que debe ser mayor que 0
  1 - (2 * theta1 * theta3) / (3 * theta2^2),
  1e-6
)


alpha <- 0.95                                              # Obtenemos el cuantil para el nivel de confianza definido
z_alpha <- qnorm(alpha)


Q_UCL <- theta1 * (                                        # Calculamos Q Cr√≠tico seg√∫n la f√≥rmula de Jackson y Mudholkar
  (z_alpha * sqrt(2 * theta2 * h0^2)) / theta1 +
    1 +
    (theta2 * h0 * (h0 - 1)) / theta1^2
)^(1 / h0)



# --- Fin de la secci√≥n de an√°lisis --- #

# --- Inicio de la secci√≥n de producci√≥n gr√°fica --- #



# --- Ampliaci√≥n de Tabla de Datos Grignolino con Resultados de T2 y Q con Evaluaci√≥n --- #

# Primero convertimos tabla y asignamos resultados de T2 y Q
df_X.Grignolino         <- as.data.frame(X.Grignolino)     # Primero convertimos la matriz a data frame
df_X.Grignolino$T2      <- T2                              # Asignamos los valores de T2 a su respectivo objeto
df_X.Grignolino$Q       <- Q                               # Asignamos los valores de Q a su respectivo objeto  

# Descripci√≥n de resultados T2 y Q por cada objeto
df_X.Grignolino$Status                 <- "Normal"                               # Asignamos una nueva columna del status del resultado de cada observaci√≥n
df_X.Grignolino$Status[T2 > T2.limit]  <- "T¬≤ fuera de control"                  # Asignamos descripci√≥n tras evaluaci√≥n
df_X.Grignolino$Status[Q  > Q_UCL]     <- "Q fuera de control"                   # Asignamos descripci√≥n tras evaluaci√≥n
df_X.Grignolino$Status[T2 > T2.limit & Q > Q_UCL]  <- "T¬≤ y Q fuera de control"  # Asignamos descripci√≥n tras evaluaci√≥n

# Transformamos las evaluacion de caracter a factor con los tres niveles previamente definidos
df_X.Grignolino$Status   <- factor(x = df_X.Grignolino$Status,
                                   levels = c("Normal", "T¬≤ fuera de control", "Q fuera de control", "T¬≤ y Q fuera de control"))

# Incluimosn el n√∫mero de observaciones como secuencia
df_X.Grignolino$Obs <- seq_len(nrow(df_X.Grignolino))




# --- Sistema de diagn√≥stico gr√°fico para T2, Q y T2 vs Q --- #

library(GGally)
library(ggplot2)
library(plotly)

# Gr√°fico Coordinado Paralelo Interactivo

# Inicio de producci√≥n de gr√°fico coordinado paralelo interactivo

p <- ggparcoord(                                # Primero producimos el gr√°fico y lo asignamos en un objeto "p"
  data = df_X.Grignolino,
  columns = 1:ncol(X.Grignolino),
  groupColumn = "Status",
  mapping = aes(
    size = Status,
    text = paste0("Obs: ", Obs, 
                  "<br>Estatus: ", Status, 
                  "<br>Valor actual T¬≤: ", round(T2, 1), " (L√≠mite T¬≤: ", round(T2.limit, 1), ")",
                  "<br>Valor actual Q: ", round(Q, 1), " (L√≠mite Q: ", round(Q_UCL, 1), ")")
    ),
  alphaLines = 1
) +

  scale_colour_manual(
    values = c(
      "Normal" = "grey70",
      "T¬≤ fuera de control" = "#265129",
      "Q fuera de control"  = "orange",
      "T¬≤ y Q fuera de control" = "red"
    )
  ) +
  
  scale_size_manual(
    values = c(
      "Normal" = 0.4,
      "T¬≤ fuera de control" = 1.2,
      "Q fuera de control"  = 1.4,
      "T¬≤ y Q fuera de control" = 1.6
    )
  ) +
  
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    legend.title = element_blank()
  ) +
  
  labs(
    title = "",
    subtitle = "",
    x = "",
    y = "Desviaciones Est√°ndar (z-score)"
  )

# Convertimos de ggplot7GGally/ggparcoord a ggploty

p1 <- ggplotly(p, 
               tooltip = "text",
               height = 675)                               # El objeto gr√°fico "p" lo reprocesamos como ggplotly para volverlo interactivo      
 
# √öltimos ajustes de formato del encabezdo y subencabezadp
p1 <- p1 %>% 
  layout(
    title = list(
      text = paste0(
        "Control Estad√≠stico de Procesos Fisicoqu√≠micos | PCA: Hotelling-Jackson",
        "<br><span style='font-size:12px;'>",
        "Verde Oscuro: desbalance del proceso (T¬≤) | ",
        "Naranja: fen√≥meno no modelado (Q) | ",
        "Rojo: desbalance (T¬≤) + fuera de modelo (Q)",
        "</span>"
      ),
      x = 0.04,        # üëâ margen horizontal elegante
      y = 0.96,        # üëâ baja ligeramente el t√≠tulo
      xanchor = "left"
    ),
    margin = list(
      t = 90           # üëâ espacio real arriba (CR√çTICO)
    )
  )

p1    

# Fin de gr√°fico paralelo coordinado


# --- Gr√°fico Hotelling T2 vs Jackson Q --- #

p_T2Q_gg <- ggplot(
  df_X.Grignolino,
  aes(
    x = T2,
    y = Q,
    colour = Status,
    text = paste0(
      "Obs: ", Obs,
      "<br>Estatus: ", Status,
      "<br>T¬≤: ", round(T2, 1), " (L√≠mite: ", round(T2.limit, 1), ")",
      "<br>Q: ", round(Q, 1), " (L√≠mite: ", round(Q_UCL, 1), ")"
    )
  )
) +
  
  geom_point(size = 2.8, alpha = 0.9) +
  
  # L√≠mites de control
  geom_vline(xintercept = T2.limit, linetype = "dashed", colour = "red") +
  geom_hline(yintercept = Q_UCL,  linetype = "dashed", colour = "red") +
  
  scale_colour_manual(
    values = c(
      "Normal" = "grey70",
      "T¬≤ fuera de control" = "#265129",
      "Q fuera de control"  = "orange",
      "T¬≤ y Q fuera de control" = "red"
    )
  ) +
  
  scale_x_continuous(
    limits = c(0, max(T2) * 1.2),
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    limits = c(0, max(Q) * 1.2),
    expand = c(0, 0)
  ) +
  
  theme_minimal() +
  theme(
    legend.title = element_blank()
  ) +
  
  labs(
    title = "",
    subtitle = "",
    x = "Hotelling T¬≤",
    y = "Q (SPE)"
  )

p_T2Q <- ggplotly(p_T2Q_gg, 
                  tooltip = "text",
                  height = 675)

p_T2Q <- p_T2Q %>%
  layout(
    title = list(
      text = paste0(
        "Diagn√≥stico Ortogonal: T¬≤ vs Q | Hotelling‚ÄìJackson",
        "<br><span style='font-size:12px;'>",
        "Verde Oscuro: desbalance del proceso (T¬≤) | ",
        "Naranja: fen√≥meno no modelado (Q) | ",
        "Rojo: desbalance (T¬≤) + fuera de modelo (Q)",
        "</span>"
      ),
      x = 0.04,        # üëâ margen horizontal elegante
      y = 0.96,        # üëâ baja ligeramente el t√≠tulo
      xanchor = "left"
    ),
    margin = list(
      t = 90           # üëâ espacio real arriba (CR√çTICO)
    )
  )

p_T2Q

# Fin de Gr√°fico Hotelling T2 vs Jackson Q



#--- Gr√°fico T2 Hotelling por PCA --- #

p_T2_gg <- ggplot(
  df_X.Grignolino,
  aes(
    x = Obs,
    y = T2,
    colour = Status,
    text = paste0(
      "Obs: ", Obs,
      "<br>Estatus: ", Status,
      "<br>T¬≤: ", round(T2, 1),
      "<br>L√≠mite T¬≤: ", round(T2.limit, 1)
    )
  )
) +
  
  # üëâ CONTINUIDAD TEMPORAL
  geom_line(
    aes(x = Obs, y = T2),
    inherit.aes = FALSE,
    colour = "grey50",
    linewidth = 0.6,
    alpha = 0.6
  ) +
  
  geom_point(size = 2.8, alpha = 0.9) +
  
  geom_hline(
    yintercept = T2.limit,
    linetype = "dashed",
    colour = "red",
    linewidth = 0.8
  ) +
  
  scale_colour_manual(
    values = c(
      "Normal" = "grey70",
      "T¬≤ fuera de control" = "#265129",
      "Q fuera de control"  = "orange",
      "T¬≤ y Q fuera de control" = "red"
    )
  ) +
  
  # üîë CLAVE ABSOLUTA
  scale_y_continuous(
    limits = c(0, max(T2) * 1.2),
    expand = c(0, 0)
  ) +
  
  theme_minimal() +
  theme(
    legend.title = element_blank()
  ) +
  labs(
    title = "",
    subtitle = "",
    x = "Observaci√≥n",
    y = "Hotelling T¬≤"
  )

p_T2 <- ggplotly(p_T2_gg, 
                 tooltip = "text",
                 height = 675)

p_T2 <- p_T2 %>%
  layout(
    title = list(
      text = paste0(
        "Gr√°fico de Control Hotelling T¬≤ (PCA)",
        "<br><span style='font-size:12px;'>",
        "Verde Oscuro: desbalance del proceso (T¬≤) | ",
        "Naranja: fen√≥meno no modelado (Q) | ",
        "Rojo: desbalance (T¬≤) + fuera de modelo (Q)",
        "</span>"
      ),
      x = 0.04,        # üëâ margen horizontal elegante
      y = 0.96,        # üëâ baja ligeramente el t√≠tulo
      xanchor = "left"
    ),
    margin = list(
      t = 90           # üëâ espacio real arriba (CR√çTICO)
    )
  )

p_T2

# Fin de Gr√°fico T2 Hotelling por PCA 



# --- Inicio de Gr√°fico Q de Jackson --- #

p_Q_gg <- ggplot(
  df_X.Grignolino,
  aes(
    x = Obs,
    y = Q,
    colour = Status,
    text = paste0(
      "Obs: ", Obs,
      "<br>Estatus: ", Status,
      "<br>Q (SPE): ", round(Q, 1),
      "<br>L√≠mite Q: ", round(Q_UCL, 1)
    )
  )
) +
  
  # üëâ CONTINUIDAD TEMPORAL
  geom_line(
    aes(x = Obs, y = Q),
    inherit.aes = FALSE,
    colour = "grey50",
    linewidth = 0.6,
    alpha = 0.6
  ) +
  
  geom_point(size = 2.8, alpha = 0.9) +
  
  geom_hline(
    yintercept = Q_UCL,
    linetype = "dashed",
    colour = "red",
    linewidth = 0.8
  ) +
  
  scale_colour_manual(
    values = c(
      "Normal" = "grey70",
      "T¬≤ fuera de control" = "#265129",
      "Q fuera de control"  = "orange",
      "T¬≤ y Q fuera de control" = "red"
    )
  ) +
  
  # üîë CLAVE: eje Y desde 0
  scale_y_continuous(
    limits = c(0, max(Q) * 1.2),
    expand = c(0, 0)
  ) +
  
  theme_minimal() +
  theme(
    legend.title = element_blank()
  ) +
  labs(
    title = "",
    subtitle = "",
    x = "Observaci√≥n",
    y = "Q (SPE)"
  )

p_Q <- ggplotly(p_Q_gg, 
                tooltip = "text",
                height = 675)

p_Q <- p_Q %>%
  layout(
    title = list(
      text = paste0(
        "Gr√°fico de Control Jackson Q (SPE) - PCA",
        "<br><span style='font-size:12px;'>",
        "Verde Oscuro: desbalance del proceso (T¬≤) | ",
        "Naranja: fen√≥meno no modelado (Q) | ",
        "Rojo: desbalance (T¬≤) + fuera de modelo (Q)",
        "</span>"
      ),
      x = 0.04,        # üëâ margen horizontal elegante
      y = 0.96,        # üëâ baja ligeramente el t√≠tulo
      xanchor = "left"
    ),
    margin = list(
      t = 90           # üëâ espacio real arriba (CR√çTICO)
    )
  )

p_Q

# Fin de Gr√°fico Q de Jackson 






# --- Inicio de Construcci√≥n de Gr√°ficos de Contribuciones t y q seg√∫n Quimiometr√≠a de Miller/Bakeev--- #


# --- Algoritmo de Charles E. Miller y Katherine Bakeev para Determinar Contribuciones t y q--- #

# Comienza el procesamiento de cada nueva observaci√≥n (del conjunto de calibraci√≥n o de monitoreo, da igual)

obs <- 5

# Autoscaling de la nueva observaci√≥n
xp.newsample <- (as.numeric(X.Grignolino[obs,]) - pca.center)/pca.scale         # Autoscale obligatorio

# Proyecci√≥n al subespacio
t.hat.new <- xp.newsample %*% pca.loadings[, 1:A]                               # Scores de la nueva observaci√≥n

#Reconstrucci√≥n del espacio original
x.hat.p <- t.hat.new %*% t(pca.loadings[,1:A])                                  # Respuesta estimada por el modelo PCA para la nueva observaci√≥n

# Residuales (SPE / Q)
e.hat.p <- xp.newsample - x.hat.p                                               # Residual de la nueva observaci√≥n; la diferencia entre la observaci√≥n original y la respuesta estimada por el modelo PCA


# C√°lculo de Hotelling T2 para cada nueva observaci√≥n (o la observaci√≥n que sea)

T2.newsample <- sum((t.hat.new^2) / diag(Lambda_scores))                        # Kucheryavskiy

# T2.newsample <- t.hat.new %*% solve(Lambda_scores) %*% t(t.hat.new)           # Miller, como referencia del √°lgebra lineal 


# C√°lculo de Q (SPE) para cada nueva observaci√≥n (o la observaci√≥n que sea)     

Q.newsample <- sum(e.hat.p^2)                                                   # Kucheryavskiy

# Q.newsample <- e.hat.p %*% t(e.hat.p)                                         # Miller, como referencia del √°lgebra lineal


# Contribuciones t (procedimiento especial de Miller, en tres pasos)

Lambda_mtx <- diag(1 / sqrt(diag(Lambda_scores)))                               # Paso 1, obtener matriz de la ra√≠z cuadrada inversa de la matriz de covarianza de los componentes principales seleccionados
t_cont <- as.numeric(t.hat.new) %*% Lambda_mtx %*% t(pca.loadings[, 1:A])       # Pasi 2, descomposici√≥n de T2 de la observaci√≥n de inter√©s
colnames(t_cont) <- rownames(pca.loadings)                                      # Paso 3


# Contribuciones q (M√©todo Miller)

q_cont <- e.hat.p                                                               # Las contribuciones q son resultado de la diferencias entre la reconstrucci√≥n del modelo y la observaci√≥n original
colnames(q_cont) <- rownames(pca.loadings)

# --- Fin de Algoritmo Matem√°tico para Determinaci√≥n de Contribuciones t y q de Miller/Bakeev ---#










# --- Inicio de gr√°fico t ---#

# --- Data frame de contribuciones t --- #

df_t_cont <- data.frame(
  Variable     = colnames(t_cont),
  Contribution = as.numeric(t_cont)
)

# Ordenamos por magnitud absoluta (diagn√≥stico)
df_t_cont <- df_t_cont[order(abs(df_t_cont$Contribution), decreasing = TRUE), ]

# Convertimos Variable en factor para respetar el orden en ggplot
df_t_cont$Variable <- factor(
  df_t_cont$Variable,
  levels = df_t_cont$Variable
)

# Inicio de gr√°fico de contribuciones t
p_t_cont_gg <- ggplot(
  df_t_cont,
  aes(
    x = Variable,
    y = Contribution,
    text = paste0(
      "Variable: ", Variable,
      "<br>Contribuci√≥n t: ", round(Contribution, 3)
    )
  )
) +
  
  geom_col(
    fill  = "#265129",
    width = 0.75
  ) +
  
  geom_hline(
    yintercept = 0,
    linetype   = "dashed",
    colour     = "grey40",
    linewidth  = 0.7
  ) +
  
  scale_y_continuous(
    limits = c(
      min(df_t_cont$Contribution) * 1.2,
      max(df_t_cont$Contribution) * 1.2
    ),
    expand = c(0, 0)
  ) +
  
  theme_minimal() +
  theme(
    axis.text.x = element_text(
      angle = 90,
      vjust = 0.5,
      hjust = 1,
      size  = 10
    ),
    plot.margin = margin(t = 10, r = 10, b = 10, l = 10)
  ) +
  
  labs(
    title = "",
    x     = "",
    y     = "Contribuci√≥n a T¬≤ (modelo PCA)"
  )

# Conversi√≥n de ggplot a ggplotly
p_t_cont <- ggplotly(p_t_cont_gg,  
                     tooltip = "text",
                     height = 675)

# Ajustes est√©ticos en ggplotly
p_t_cont <- p_t_cont %>%
  layout(
    title = list(
      text = paste0(
        "Contribuciones Individuales t a la Varianza Total (Hotelling T¬≤)",
        "<br><span style='font-size:12px;'>",
        "Diagn√≥stico de desplazamiento dentro del subespacio PCA ‚Äî Observaci√≥n ",
        obs,
        "</span>"
      ),
      x       = 0.04,
      y       = 0.96,
      xanchor = "left"
    ),
    margin = list(
      t = 90
    )
  )

#p_t_cont

# Fin de gr√°fico de contribuciones t








# --- Inicio de gr√°fico q ---#


# --- Data frame de contribuciones q --- #

df_q_cont <- data.frame(
  Variable     = colnames(q_cont),
  Contribution = as.numeric(q_cont)
)

# Ordenamos por magnitud absoluta (diagn√≥stico)
df_q_cont <- df_q_cont[order(abs(df_q_cont$Contribution), decreasing = TRUE), ]

# Convertimos Variable en factor para respetar el orden en ggplot
df_q_cont$Variable <- factor(
  df_q_cont$Variable,
  levels = df_q_cont$Variable
)

# --- Inicio de gr√°fico de contribuciones q --- #
p_q_cont_gg <- ggplot(
  df_q_cont,
  aes(
    x = Variable,
    y = Contribution,
    text = paste0(
      "Variable: ", Variable,
      "<br>Contribuci√≥n q: ", round(Contribution, 3)
    )
  )
) +
  
  geom_col(
    fill  = "orange",
    width = 0.75
  ) +
  
  geom_hline(
    yintercept = 0,
    linetype   = "dashed",
    colour     = "grey40",
    linewidth  = 0.7
  ) +
  
  scale_y_continuous(
    limits = c(
      min(df_q_cont$Contribution) * 1.2,
      max(df_q_cont$Contribution) * 1.2
    ),
    expand = c(0, 0)
  ) +
  
  theme_minimal() +
  theme(
    axis.text.x = element_text(
      angle = 90,
      vjust = 0.5,
      hjust = 1,
      size  = 10
    ),
    plot.margin = margin(t = 10, r = 10, b = 10, l = 10)
  ) +
  
  labs(
    title = "",
    x     = "",
    y     = "Contribuci√≥n a Q (SPE)"
  )

# Conversi√≥n de ggplot a ggplotly
p_q_cont <- ggplotly(
                     p_q_cont_gg,
                     tooltip = "text",
                     height = 675)

# Ajustes est√©ticos en ggplotly
p_q_cont <- p_q_cont %>%
  layout(
    title = list(
      text = paste0(
        "Contribuciones Individuales q a los Residuales (SPE)",
        "<br><span style='font-size:12px;'>",
        "Diagn√≥stico de informaci√≥n no capturada por el modelo PCA ‚Äî Observaci√≥n ",
        obs,
        "</span>"
      ),
      x       = 0.04,
      y       = 0.96,
      xanchor = "left"
    ),
    margin = list(
      t = 90
    )
  )

#p_q_cont

# Fin de gr√°fico de contribuciones q




# --- Guardar objetos finales para sitio Quarto ---"

getwd()

dir.create("objects", showWarnings = FALSE)

saveRDS(p1,      "objects/p1_parcoord.rds")
saveRDS(p_T2Q,   "objects/p_T2Q.rds")
saveRDS(p_T2,    "objects/p_T2.rds")
saveRDS(p_Q,     "objects/p_Q.rds")

# Gr√°ficos dee controbici√≥n por cada observaci√≥n

saveRDS(p_t_cont,"objects/p_t_cont5.rds")
saveRDS(p_q_cont,"objects/p_q_cont5.rds")

# Test

getwd()

p1coord  <- readRDS("objects/p1_parcoord.rds")
p1T2Q    <- readRDS("objects/p_T2Q.rds")
p1T2     <- readRDS("objects/p_T2.rds")
p1Q      <- readRDS("objects/p_Q.rds")

gt <- readRDS("objects/p_t_cont1.rds")
qt <- readRDS("objects/p_q_cont1.rds")











# --- Inicio de integraci√≥n de gr√°ficos de diagn√≥stico multivariable como objetos conjuntos --- #

library(htmltools)
library(htmlwidgets)

# 1 - Gr√°fico Parcoord en html

html_page_p1 <- tagList(      
  
  tags$h2(""),
  
  p1,
  
  tags$hr()
)

browsable(html_page_p1)

# üíæ Guardar correctamente
save_html(
  html_page_p1,
  file = "diagnostico_multivariado_p1.html"
)



# 2 - Gr√°ficos T2-Q, T2 y Q

html_page_T2Q <- tagList(
  
  tags$h2(""),
  p_T2Q,
  
  tags$hr(),
  
  tags$h2(""),
  p_T2,
  
  tags$hr(),
  
  tags$h2(""),
  p_Q
)


browsable(html_page_T2Q)


# üíæ Guardar correctamente
save_html(
  html_page_T2Q,
  file = "diagnostico_multivariado_T2_Q.html"
)

        



# 3 - Gr√°ficos de Contribuciones t y q

html_page_tq_cont <- tagList(
  
  # --- Row 1: t-cont ---
  tags$h2(""),
  p_t_cont,
  
  tags$hr(),
  
  # --- Row 2: q-cont ---
  tags$h2(""),
  p_q_cont,
  
  tags$hr()
)


browsable(html_page_tq_cont)


# üíæ Guardar correctamente
save_html(
  html_page_tq_cont,
  file = "diagnostico_multivariado_tq_cont.html"
)


# --- Fin de integraci√≥n de gr√°ficos de diagn√≥stico multivariable como objetos conjuntos --- #

        
        
library(htmltools)

index_page <- tags$html(
  
  tags$head(
    tags$title("Diagn√≥stico Multivariado PCA ‚Äî √çndice"),
    tags$style(HTML("
      body {
        font-family: Arial, sans-serif;
        margin: 40px;
        background-color: #fafafa;
      }
      h1 {
        margin-bottom: 10px;
      }
      p {
        max-width: 900px;
        color: #444;
      }
      ul {
        margin-top: 30px;
        font-size: 1.1em;
      }
      li {
        margin-bottom: 15px;
      }
      a {
        text-decoration: none;
        color: #0056b3;
      }
      a:hover {
        text-decoration: underline;
      }
    "))
  ),
  
  tags$body(
    
    tags$h1("Diagn√≥stico Multivariado por PCA"),
    
    tags$p(
      "Este √≠ndice permite acceder a los distintos m√≥dulos de diagn√≥stico ",
      "multivariable utilizados para el control estad√≠stico de procesos fisicoqu√≠micos ",
      "mediante PCA, Hotelling T¬≤ y estad√≠stico Q (SPE)."
    ),
    
    tags$ul(
      
      tags$li(
        tags$a(
          href = "diagnostico_multivariado_p1.html",
          target = "_blank",
          "1. Vista Multivariable Global ‚Äî Gr√°fico de Coordenadas Paralelas"
        )
      ),
      
      tags$li(
        tags$a(
          href = "diagnostico_multivariado_T2_Q.html",
          target = "_blank",
          "2. Diagn√≥stico Ortogonal ‚Äî Plano T¬≤‚ÄìQ y Evoluci√≥n Temporal"
        )
      ),
      
      tags$li(
        tags$a(
          href = "diagnostico_multivariado_tq_cont.html",
          target = "_blank",
          "3. Identificaci√≥n de Variables ‚Äî Contribuciones t y q"
        )
      )
      
    ),
    
    tags$hr(),
    
    tags$p(
      style = "font-size: 0.9em; color: #666;",
      "Reporte generado autom√°ticamente a partir de an√°lisis multivariado PCA. ",
      "Los gr√°ficos son interactivos y se abren en ventanas independientes."
    )
  )
)

# üíæ Guardar √≠ndice
save_html(
  index_page,
  file = "index_diagnostico_multivariado.html"
)









        

# --- Estructuraci√≥n del Contenido en una Lista para Producir Archivo RDS --- #

calibration <- list(
  
  # 1. Datos crudos
  datos = italian.wine.data.raw,
  
  # 2. Datos de inter√©s
  
  datos.interes = X.Barolo,
  
  # . Modelo PCA
  pca = pca.Barolo,                               # prcomp completo
  
  # 2. Preprocesamiento (CR√çTICO)
  center = pca$center,
  scale  = pca$scale,
  
  # 3. Estructura del sistema
  loadings = pca.Barolo$rotation,
  scores   = pca.Barolo$x,
  sdev     = pca.Barolo$sdev,
  
  # 4. L√≠mites de control
  limits = list(
    T2 = T2_limits,
    Q  = Q_limits
  ),
  
  # 5. Sub-sistemas (tu aporte conceptual)
  subsistemas = list(
    PC1 = subsistema1_loadings,
    PC2 = subsistema2_loadings,
    PC3 = subsistema3_loadings,
    PC4 = subsistema4_loadings
  ),
  
  # 6. Densidades / geometr√≠a y otros elementos KDE
  kde = pca.Barolo.dens3d,
  
  x.latt = x.latt,
  y.latt = y.latt,
  z.latt = z.latt,
  
  qalpha  = qalpha, 
  qcols   = qcols,
  qlevels = qlevels,
  
  # 7. Elementos de colores
  pal_fun    = pal_fun,
  data_ncol  = data_ncol, 
  sist4.cols = sist4.cols, 
  data_cols  = data_cols,
  
  # 8. Metadatos (NO subestimar esto)
  meta = list(
    created = Sys.time(),
    n_obs   = nrow(X.Barolo),
    n_var   = ncol(X.Barolo),
    vars    = colnames(X.Barolo),
    method  = "PCA + T2 + Q",
    author  = "Q.I. Victor Soto Del Toro"
  )
)

# --- Creaci√≥n de Archivo RDS incluyendo todo el contenido generado en este script de an√°lisis --- #

saveRDS(calibration, "calibration_model.rds")

